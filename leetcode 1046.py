import heapq
from typing import List

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        """
        計算最後一塊石頭的重量
        :param stones: 石頭重量列表
        :return: 最後剩下的石頭重量，如果沒有石頭剩下則返回 0
        """
        while stones:  # 當石頭列表不為空時，繼續處理
            stones = sorted(stones, reverse=False)  # 將石頭列表升序排序
            
            s1 = stones.pop()  # 取出最重的石頭
            if not stones:  # 如果沒有其他石頭了，返回 s1
                return s1
            s2 = stones.pop()  # 取出第二重的石頭
            if s1 > s2:  # 如果 s1 比 s2 重，將差值放回石頭列表
                stones.insert(len(stones), s1 - s2)
        return 0  # 如果沒有石頭剩下，返回 0


# 測試範例
stones = [2, 7, 4, 1, 8, 1]
solution = Solution()
print(solution.lastStoneWeight(stones))  # 輸出結果

'''
LeetCode 1046: 最後一塊石頭的重量

題目翻譯：
有一堆石頭，每塊石頭的重量都是正整數。每一回合，我們選擇兩塊最重的石頭並將它們一起粉碎。假設兩塊石頭的重量分別為 x 和 y，且 x <= y。粉碎的結果如下：
1. 如果 x == y，則兩塊石頭都會被完全粉碎；
2. 如果 x != y，則重量為 x 的石頭會被完全粉碎，而重量為 y 的石頭會剩下 y - x。
最後，最多只會剩下一塊石頭。返回這塊石頭的重量。如果沒有石頭剩下，則返回 0。

題目需求：
1. 模擬石頭粉碎的過程，每次選擇兩塊最重的石頭進行粉碎。
2. 返回最後剩下的石頭重量，如果沒有石頭剩下，則返回 0。

原始代碼的問題：
1. 使用排序的方式來找到最重的兩塊石頭，時間複雜度較高（每次排序為 O(n log n)）。
2. 插入新石頭時，使用 insert 方法，時間複雜度為 O(n)，效率較低。
3. 整體時間複雜度為 O(n^2 log n)，對於大數據量會較慢。

解題思路與拆解：
1. 問題分析：
   - 每次需要找到兩塊最重的石頭，這可以使用最大堆（Max Heap）來高效實現。
   - 粉碎後的結果需要重新放回堆中，直到堆中只剩下一塊石頭或沒有石頭。

2. 解題方法選擇：
   - 使用堆（Heap）來高效找到最重的兩塊石頭，並處理粉碎後的結果。
   - 時間複雜度為 O(n log n)，空間複雜度為 O(n)。

3. 解題步驟：
   - 將石頭列表轉換為最大堆。
   - 每次取出堆頂的兩個元素（最重的兩塊石頭）。
   - 根據粉碎規則處理這兩塊石頭，並將結果放回堆中。
   - 重複上述步驟，直到堆中剩下一塊石頭或沒有石頭。

重點筆記：
1. **堆的使用**:
   - 使用最大堆來高效找到最重的兩塊石頭。
   - Python 的 heapq 模組默認是最小堆，可以通過取負數來模擬最大堆。

2. **時間複雜度**:
   - 每次堆操作的時間複雜度為 O(log n)。
   - 整體時間複雜度為 O(n log n)。

3. **空間複雜度**:
   - 需要 O(n) 的空間來存儲堆。

4. **適用場景**:
   - 適用於需要高效找到最大或最小元素的場景。
   - 例如優先級隊列、任務調度等。

範例解析：
- 輸入：stones = [2, 7, 4, 1, 8, 1]
- 過程：
  - 第一回合：8 和 7 粉碎，剩下 1，石頭列表變為 [2, 4, 1, 1, 1]。
  - 第二回合：4 和 2 粉碎，剩下 2，石頭列表變為 [1, 1, 1, 2]。
  - 第三回合：2 和 1 粉碎，剩下 1，石頭列表變為 [1, 1, 1]。
  - 第四回合：1 和 1 粉碎，剩下 0，石頭列表變為 [1]。
  - 最後剩下 1。
- 輸出：1

函式功能說明：
- `class Solution`：封裝解決方案的類。
- `lastStoneWeight(self, stones)`：計算最後一塊石頭的重量。
- `heapq`：Python 的堆模組，用於高效管理優先級隊列。
- `sorted()`：對列表進行排序。
- `pop()`：移除並返回列表的最後一個元素。
- `insert()`：在指定位置插入元素。
'''

