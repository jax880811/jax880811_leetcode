class Solution {
    
    removeElement(nums, val) {
        // 初始化指針 k，用於追蹤新陣列的長度（不包含 val 的元素）
        let k = 0;

        // 遍歷原始陣列 nums
        for (let i = 0; i < nums.length; i++) {
            // 如果當前元素不等於要移除的值 val
            if (nums[i] !== val) {
                // 將當前元素移動到 nums 陣列的前面（索引為 k 的位置）
                nums[k] = nums[i];
                // 將 k 指針向後移動一位，指向下一個可用的位置
                k++;
            }
            // 如果當前元素等於 val，則跳過，相當於移除
        }

        // k 的值就是移除元素後陣列的新長度
        return k;
    }
} 




let nums = [3,2,2,3];
let val = 3;

// 創建 Solution 的實例
let solution = new Solution();


console.log(solution.removeElement(nums,val));

/*
LeetCode 27: 移除元素 (Remove Element) (Node.js 實現)

題目翻譯：
給你一個陣列 `nums` 和一個值 `val`，你需要原地移除所有數值等於 `val` 的元素，並返回移除後陣列的新長度。

不要使用額外的陣列空間，你必須在原地修改輸入陣列並只使用 O(1) 額外的空間。

元素的順序可以更改。你不需要考慮陣列中超出新長度的元素。

題目需求：
1. 從給定的陣列 `nums` 中移除所有等於給定值 `val` 的元素。
2. 必須原地修改輸入陣列。
3. 只能使用 O(1) 的額外空間。
4. 返回移除後陣列的新長度。
5. 元素的順序可以改變。

解題思路與拆解：
1. 問題分析：
   - 需要在原陣列上操作，移除指定的元素。
   - 不能使用額外的陣列來儲存結果。
   - 返回的是移除後陣列的長度，而不是新的陣列本身。

2. 解題方法選擇：
   - 方法一：雙指針法 (Two Pointers) (本解法採用) - 時間 O(N)，空間 O(1)

3. 解題步驟 (雙指針法)：
   - 初始化一個指針 `k` 為 0。這個指針將用於追蹤新陣列（不包含 `val` 的元素）的下一個可用位置。
   - 使用另一個指針 `i` 遍歷原始陣列 `nums`，從索引 0 到 `nums.length - 1`。
   - 對於 `nums` 中的每個元素 `nums[i]`：
     - 如果 `nums[i]` 不等於 `val`，則將 `nums[i]` 複製到 `nums[k]` 的位置，然後將 `k` 向右移動一位 (`k++`)。這表示我們在新的有效部分陣列中找到了一個需要保留的元素，並將其放置在正確的位置。
     - 如果 `nums[i]` 等於 `val`，則我們跳過這個元素，因為它需要被移除。指針 `i` 會繼續向前移動，尋找下一個需要保留的元素。
   - 當指針 `i` 遍歷完整個原始陣列後，指針 `k` 的值就是新陣列的長度，因為 `k` 記錄了所有不等於 `val` 的元素被放置的位置的數量。
   - 返回 `k`。

重點筆記：
1. **原地修改 (In-place Modification)**:
   - 題目明確要求在原地修改陣列，這意味著我們不能創建一個新的陣列來儲存結果。雙指針法非常適合這種場景。

2. **雙指針技巧**:
   - 使用兩個指針 `i` 和 `k`，其中 `i` 用於遍歷原始陣列，`k` 用於指向新陣列的下一個可用位置。
   - 只有當 `nums[i]` 不等於 `val` 時，我們才將其移動到 `nums[k]` 並增加 `k`。

3. **時間複雜度**:
   - O(N)，其中 N 是陣列 `nums` 的長度。我們需要遍歷整個陣列一次。

4. **空間複雜度**:
   - O(1)，我們只使用了常數級別的額外空間（兩個指針 `i` 和 `k`）。

5. **返回值是長度**:
   - 注意題目要求返回的是移除元素後陣列的新長度，而不是新的陣列本身。雖然 `nums` 陣列的前 `k` 個元素會是不包含 `val` 的元素，但超出長度 `k` 的元素的值可以是任意的。

6. **元素順序**:
   - 題目允許改變元素的順序。這個雙指針方法會將不等於 `val` 的元素移動到陣列的前面，但它們的相對順序可能會改變。例如，如果 `nums = [3,2,2,3]` 且 `val = 3`，結果可能是 `[2,2,_,_]`，長度為 2。原始的 2 的順序被保留了。

範例解析 (nums = [3,2,2,3], val = 3):
- 初始化 `k = 0`。
- 遍歷 `nums`：
  - `i = 0`, `nums[0] = 3`，等於 `val`，跳過。
  - `i = 1`, `nums[1] = 2`，不等於 `val`，`nums[k] = nums[1]` (即 `nums[0] = 2`)，`k` 變為 1。現在 `nums` 是 `[2,2,2,3]`。
  - `i = 2`, `nums[2] = 2`，不等於 `val`，`nums[k] = nums[2]` (即 `nums[1] = 2`)，`k` 變為 2。現在 `nums` 是 `[2,2,2,3]`。
  - `i = 3`, `nums[3] = 3`，等於 `val`，跳過。
- 遍歷結束，`k` 的值是 2，所以新的長度是 2。陣列 `nums` 的前兩個元素是 `[2, 2]`。

函式功能說明 (已移動到程式碼的行內註解):
- `class Solution`: 定義解決方案類別。
- `removeElement(nums, val)`: 移除陣列中指定元素的核心方法。
- `let k = 0;`: 初始化指向新陣列下一個可用位置的指針。
- `for (let i = 0; i < nums.length; i++)`: 遍歷原始陣列。
- `if (nums[i] !== val)`: 檢查當前元素是否不等於目標值。
- `nums[k] = nums[i];`: 將不等於目標值的元素移動到 `nums[k]` 的位置。
- `k++;`: 將 `k` 指針向後移動一位。
- `return k;`: 返回新的長度。
- `const nums = [...]`: 定義測試範例的陣列。
- `const val = ...`: 定義要移除的值。
- `const solution = new Solution();`: 創建 `Solution` 實例。
- `console.log(...)`: 調用方法並打印結果。
*/