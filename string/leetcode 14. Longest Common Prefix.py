class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        # 如果輸入的字串列表為空，則沒有共同前綴，返回空字串。
        if not strs:
            return ""

        # 如果列表中只有一個字串，那麼它本身就是最長共同前綴。
        if len(strs) == 1:
            return strs[0]

        # 我們將第一個字串作為比較的基準。
        first_str = strs[0]
        num_strs = len(strs)

        # 迭代第一個字串的每個字元。
        for i in range(len(first_str)):
            char = first_str[i]  # 取得第一個字串在當前索引 i 的字元。

            # 迭代列表中的其他字串（從第二個字串開始）。
            for j in range(1, num_strs):
                current_str = strs[j]

                # 檢查當前字串是否比第一個字串短，或者當前字串在索引 i 的字元是否與第一個字串在索引 i 的字元不同。
                if i == len(current_str) or current_str[i] != char:
                    # 如果條件成立，表示我們已經找到了共同前綴的末尾。
                    # 返回第一個字串從開頭到當前索引 i 的子字串。
                    return first_str[:i]
        
        # 如果迴圈完整執行完畢，表示第一個字串的所有字元都是所有其他字串的前綴。
        # 因此，第一個字串本身就是最長共同前綴。
        return first_str

# 測試範例
strs1 = ["flower","flow","flight"]
print(f"最長共同前綴：{Solution().longestCommonPrefix(strs1)}")  # 輸出：最長共同前綴：fl

strs2 = ["dog","racecar","car"]
print(f"最長共同前綴：{Solution().longestCommonPrefix(strs2)}")  # 輸出：最長共同前綴：

strs3 = ["apple"]
print(f"最長共同前綴：{Solution().longestCommonPrefix(strs3)}")  # 輸出：最長共同前綴：apple

strs4 = [""]
print(f"最長共同前綴：{Solution().longestCommonPrefix(strs4)}")  # 輸出：最長共同前綴：

strs5 = ["cir","car"]
print(f"最長共同前綴：{Solution().longestCommonPrefix(strs5)}")  # 輸出：最長共同前綴：c

"""
LeetCode 14: 最長共同前綴 (Longest Common Prefix) (Python 實現)

題目翻譯：
編寫一個函數來查找字串列表（list）中最長的共同前綴字串。
如果沒有共同前綴，則返回一個空字串 ""。

題目需求：
1. 接收一個字串列表作為輸入。
2. 找出列表中所有字串共有的最長前綴。
3. 如果沒有共同前綴，返回空字串。

解題思路與拆解：
1. 問題分析：
   - 我們需要比較列表中的所有字串，找出它們從頭開始相同的字元序列。
   - 如果列表為空，或者沒有任何共同的起始字元，則結果應該是空字串。

2. 解題方法選擇：
   - 方法一：水平掃描 (本解法採用) - 逐個字串比較，不斷縮小共同前綴的範圍。
   - 方法二：垂直掃描 - 逐個字元比較所有字串在相同位置的字元。
   - 方法三：分治法 - 將字串列表分成兩半，遞迴地找到兩部分的共同前綴，然後再找到這兩個前綴的共同前綴。
   - 方法四：排序法 - 將字串列表排序後，只需要比較第一個和最後一個字串的共同前綴。

3. 解題步驟 (水平掃描 - 本解法實際採用的是垂直掃描的思想)：
   - **步驟 1：處理邊緣情況。**
     - 如果輸入的字串列表 `strs` 為空 (`not strs`)，則直接返回空字串 `""`，因為沒有字串可以比較。
     - 如果列表中只有一個字串 (`len(strs) == 1`)，那麼這個字串本身就是最長的共同前綴，直接返回 `strs[0]`。
   - **步驟 2：選擇基準字串。**
     - 我們選擇列表中的第一個字串 `strs[0]` 作為比較的基準。我們將逐個字元地與其他字串進行比較。
   - **步驟 3：迭代基準字串的字元。**
     - 使用一個 `for` 迴圈，從索引 `i = 0` 開始，遍歷基準字串 `first_str` 的每個字元。
   - **步驟 4：比較當前字元與其他字串的相同位置的字元。**
     - 在外層迴圈的每一次迭代中，我們取得基準字串在當前索引 `i` 的字元 `char = first_str[i]`。
     - 然後，我們使用另一個 `for` 迴圈，從列表的第二個字串開始 (`j = 1`)，遍歷剩餘的字串。
   - **步驟 5：檢查是否找到共同前綴的末尾。**
     - 對於每個剩餘的字串 `current_str = strs[j]`，我們進行兩個檢查：
       - `i == len(current_str)`: 檢查當前索引 `i` 是否已經等於當前字串的長度。如果是，表示當前字串比基準字串短，且基準字串到目前為止的部分是共同前綴。因此，共同前綴的長度到索引 `i` 為止。
       - `current_str[i] != char`: 檢查當前字串在索引 `i` 的字元是否與基準字串在索引 `i` 的字元 `char` 不同。如果是，表示在當前索引處，字元不相同，共同前綴到索引 `i` 為止。
     - 如果上述任一條件成立，我們使用 `first_str[:i]` 返回基準字串從開頭到索引 `i` 的子字串。這就是我們找到的最長共同前綴。
   - **步驟 6：如果所有字串都匹配到基準字串的末尾。**
     - 如果外層迴圈完整執行完畢，沒有在任何時候返回，這表示基準字串的所有字元都是所有其他字串的前綴。在這種情況下，最長的共同前綴就是基準字串本身，我們返回 `first_str`。

重點筆記：
1. **空列表處理：** 輸入為空列表時，應返回空字串。
2. **單字串處理：** 輸入列表只有一個字串時，該字串就是最長共同前綴。
3. **基準字串選擇：** 選擇第一個字串作為基準進行比較是常見的做法。
4. **垂直比較：** 實際上，我們的比較方式是垂直的，即比較所有字串在相同索引位置的字元。
5. **提前返回：** 一旦發現不匹配的字元或某個字串的長度不足，我們就可以立即返回當前找到的共同前綴。
6. **完整匹配：** 如果基準字串的所有字元都與其他字串在相同位置的字元匹配，則基準字串本身就是最長共同前綴。

時間複雜度：O(S)，其中 S 是所有字串中字元的總數。在最壞情況下，所有字串都相同，我們需要比較所有字串的所有字元。
空間複雜度：O(1)，我們只使用了常數級別的額外空間。

函數功能說明：
- `longestCommonPrefix(self, strs: list[str]) -> str`: 接收一個字串列表 `strs`，返回它們之間的最長共同前綴字串。
- `if not strs`: 檢查輸入列表是否為空。
- `if len(strs) == 1`: 檢查輸入列表是否只有一個字串。
- `first_str = strs[0]`: 將列表中的第一個字串作為基準。
- `num_strs = len(strs)`: 取得字串列表的長度。
- `for i in range(len(first_str))`: 迭代基準字串的每個字元。
- `char = first_str[i]`: 取得基準字串在當前索引的字元。
- `for j in range(1, num_strs)`: 迭代列表中的其他字串。
- `current_str = strs[j]`: 取得當前比較的字串。
- `if i == len(current_str) or current_str[i] != char`: 檢查是否超出當前字串長度或字元不匹配。
- `return first_str[:i]`: 返回共同前綴。
- `return first_str`: 如果迴圈完成，表示第一個字串是共同前綴。
"""