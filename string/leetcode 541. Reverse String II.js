class Solution {
    /**
     * @param {string} s
     * @param {number} k
     * @return {string}
     */
    reverseStr = function (s, k) {
        let arr = s.split(''); // 將輸入字串 s 轉換為字元陣列 arr，以便進行原地修改。
        let n = arr.length; // 取得字串（陣列）的長度，儲存在變數 n 中。

        // 使用 for 迴圈遍歷字串（陣列）。迴圈從索引 0 開始，每次增加 2 * k。
        // 這樣可以讓我們每次處理一個長度為 2k 的區塊。
        for (let i = 0; i < n; i += 2 * k) {
            let start = i; // 設定當前需要反轉的區塊的起始索引為 i。
            // 設定當前需要反轉的區塊的結束索引。
            // 計算公式是 i + k - 1，但需要與陣列的最後一個索引 n - 1 比較取較小值，以防止超出陣列邊界。
            // 這處理了剩餘字元不足 k 個的情況。
            let end = Math.min(i + k - 1, n - 1);

            // 使用 while 迴圈對當前區塊 [start, end] 進行原地反轉。
            // 迴圈持續條件是當 start 指針小於 end 指針時。
            while (start < end) {
                // 使用解構賦值（或臨時變數）來交換 start 指針和 end 指針指向的字元。
                [arr[start], arr[end]] = [arr[end], arr[start]];
                start += 1; // 將 start 指針向右移動一位。
                end -= 1; // 將 end 指針向左移動一位。
            }
        }

        // 在遍歷和反轉所有需要處理的區塊後，將修改後的字元陣列 arr 轉換回字串。
        return arr.join('');
    }
}

// 測試範例
let s = "abcdefg";
let k = 2;

// 創建 Solution 的實例
let solution = new Solution();

// 調用 reverseStr 方法並輸出結果
console.log(solution.reverseStr(s, k));

/*
LeetCode 541: 反轉字串 II (Reverse String II) (Node.js 實現)

題目翻譯：
給定一個字串 `s` 和一個整數 `k`，你需要從字串的開頭算起，每隔 `2k` 個字元反轉前 `k` 個字元。

- 如果剩餘字元少於 `k` 個，則將剩餘的所有字元都反轉過來。
- 如果剩餘字元大於等於 `k` 但少於 `2k` 個，則反轉前 `k` 個字元，並將剩餘的字元保持不變。

題目需求：
1. 接收一個字串 `s` 和一個整數 `k` 作為輸入。
2. 按照規則反轉字串 `s`。
3. 返回反轉後的字串。

解題思路與拆解：
1. 問題分析：
   - 我們需要對字串進行分組處理，每 `2k` 個字元為一組。
   - 在每個分組中，只反轉前 `k` 個字元。
   - 需要處理字串末尾剩餘字元數不足 `k` 或介於 `k` 和 `2k` 之間的情況。

2. 解題方法選擇：
   - 將字串轉換為陣列：由於 JavaScript 的字串是不可變的，為了方便進行原地反轉操作，我們首先將字串轉換為字元陣列。
   - 迭代處理：我們可以使用迴圈來遍歷字串，每次處理 `2k` 個字元的區塊。
   - 雙指針反轉：對於每個需要反轉的區間，可以使用雙指針法進行原地反轉。

3. 解題步驟：
   - **步驟 1：轉換為陣列。**
     - 使用 `s.split('')` 將輸入字串 `s` 轉換為一個字元陣列 `arr`。
   - **步驟 2：遍歷字串。**
     - 使用 `for` 迴圈遍歷 `arr`，迴圈的步長設定為 `2 * k`。這樣可以確保我們每次處理一個長度為 `2k` 的區塊。迴圈變數 `i` 代表每個區塊的起始索引。
   - **步驟 3：確定反轉區間。**
     - 對於每個起始索引 `i`，我們需要確定需要反轉的區間。反轉應該從 `i` 開始，到 `Math.min(i + k - 1, n - 1)` 結束，其中 `n` 是字串的長度。`Math.min` 用於處理字串末尾剩餘字元少於 `k` 的情況，此時我們只需要反轉剩餘的所有字元。
   - **步驟 4：反轉區間。**
     - 使用雙指針法反轉從 `start`（即 `i`）到 `end` 的字元。
       - 初始化 `start = i` 和 `end = Math.min(i + k - 1, n - 1)`。
       - 使用 `while (start < end)` 迴圈進行反轉：
         - 交換 `arr[start]` 和 `arr[end]` 的值。
         - 將 `start` 指針向右移動一位 (`start++`)。
         - 將 `end` 指針向左移動一位 (`end--`)。
   - **步驟 5：轉換回字串。**
     - 在遍歷完所有需要處理的區塊後，使用 `arr.join('')` 將反轉後的字元陣列轉換回字串。
   - **步驟 6：返回結果。**
     - 返回最終反轉後的字串。

重點筆記：
1. **步長為 `2k`：** 我們以 `2k` 為步長遍歷字串，因為每 `2k` 個字元中只有前 `k` 個需要反轉。
2. **反轉區間的邊界：** 需要使用 `Math.min` 來確保反轉的結束索引不會超出字串的邊界，特別是當字串末尾的剩餘字元數少於 `k` 時。
3. **雙指針反轉：** 雙指針法是一種原地反轉陣列或字串區間的有效方法。
4. **字串的不可變性：** 在 JavaScript 中，字串是不可變的，所以我們需要先將其轉換為陣列才能進行原地修改。

時間複雜度：O(n)，其中 n 是字串 `s` 的長度。我們遍歷了整個字串一次，並且對於每個需要反轉的區塊，也進行了一次線性時間的反轉操作。
空間複雜度：O(n)，因為我們將字串轉換為字元陣列。如果允許直接操作字串（在某些語言中），空間複雜度可以為 O(1)。

函數功能說明：
- `reverseStr(s, k)`: 接收一個字串 `s` 和一個整數 `k`，按照規則反轉字串並返回結果。
- `let arr = s.split('')`: 將字串轉換為字元陣列。
- `let n = arr.length`: 獲取字串長度。
- `for (let i = 0; i < n; i += 2 * k)`: 以 `2k` 為步長遍歷字串。
- `let start = i`: 設定反轉區間的起始索引。
- `let end = Math.min(i + k - 1, n - 1)`: 設定反轉區間的結束索引，確保不超出邊界。
- `while (start < end)`: 使用雙指針反轉區間內的字元。
- `[arr[start], arr[end]] = [arr[end], arr[start]]`: 交換字元。
- `start += 1`, `end -= 1`: 移動指針。
- `return arr.join('')`: 將反轉後的陣列轉換回字串並返回。
*/