class Solution {

    /**
     * @param {number[][]} obstacleGrid
     * @return {number}
     */
    uniquePathsWithObstacles(obstacleGrid) {
        // 獲取網格的行數和列數。
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;

    // 如果起始單元格就是障礙物，則無法到達，返回 0。
    if (obstacleGrid[0][0] === 1) {
        return 0;
    }

    // 創建一個 DP 表格，用於儲存到達每個單元格的唯一路徑數。
    // 將 DP 表格初始化為與障礙物網格相同大小，並填充 0。
    const dp = Array(m).fill(null).map(() => Array(n).fill(0));

    // 初始化起始單元格。
    // 到達 (0, 0) 的路徑數為 1 (因為它不是障礙物)。
    dp[0][0] = 1;

    // 填充第一行。
    // 對於第一行的每個單元格 (0, j)，如果它不是障礙物，則到達它的路徑數等於到達 (0, j-1) 的路徑數。
    // 如果 (0, j) 是障礙物，或者 (0, j-1) 無法到達 (dp[0][j-1] 為 0)，則 (0, j) 也無法到達。
    for (let j = 1; j < n; j++) {
        if (obstacleGrid[0][j] === 0 && dp[0][j - 1] === 1) {
            dp[0][j] = 1;
        }
    }

    // 填充第一列。
    // 對於第一列的每個單元格 (i, 0)，如果它不是障礙物，則到達它的路徑數等於到達 (i-1, 0) 的路徑數。
    // 如果 (i, 0) 是障礙物，或者 (i-1, 0) 無法到達 (dp[i-1][0] 為 0)，則 (i, 0) 也無法到達。
    for (let i = 1; i < m; i++) {
        if (obstacleGrid[i][0] === 0 && dp[i - 1][0] === 1) {
            dp[i][0] = 1;
        }
    }

    // 填充網格的其餘部分。
    // 對於每個單元格 (i, j)，如果它不是障礙物，則到達它的路徑數等於從上面來的路徑數加上從左邊來的路徑數。
    // 如果 (i, j) 是障礙物，則到達它的路徑數為 0。
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 0) { // 如果當前單元格不是障礙物
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 路徑數 = 從上面來的路徑數 + 從左邊來的路徑數
            }
            // 如果是障礙物，dp[i][j] 保持為 0 (初始化時已經設定)。
        }
    }

    // 最終結果是到達右下角單元格的路徑數。
    return dp[m - 1][n - 1];
    }
}

// 測試範例
const solution = new Solution();

let obstacleGrid = [
  [0, 0, 0],
  [0, 1, 0],
  [0, 0, 0]
];

// 輸出：2，因為有兩條合法的路徑可以避開障礙到達終點。
console.log(solution.uniquePathsWithObstacles(obstacleGrid));

/*
LeetCode 63: 不同路徑 II (Unique Paths II) (Node.js 實現)

題目翻譯：
給定一個 m x n 的網格 obstacleGrid，裡面有障礙物 (1) 和空地 (0)，
機器人只能向右或向下移動一步，請計算從左上角走到右下角的所有合法路徑數量。

題目需求：
1. 接收一個二維整數陣列 obstacleGrid 作為輸入。
2. 陣列中 1 表示障礙物、0 表示可走位置。
3. 起點與終點不一定是空地。
4. 返回所有從起點走到終點，**不穿越障礙**的合法路徑總數。

解題思路與拆解：
本解法使用動態規劃（Dynamic Programming）處理每個格子的可行路徑數。

1. 問題分析：
   - 每一格的值為「從起點到此格的所有合法路徑數量」
   - 起點或終點若為障礙 → 回傳 0
   - 若當前為障礙 → dp[i][j] = 0
   - 若無障礙 → dp[i][j] = dp[i-1][j] + dp[i][j-1]

2. 解題方法選擇：
   - 方法一：建立完整的 dp 二維陣列來記錄每格的走法（本解法）。
   - 方法二：空間優化為一維陣列（進階解法）。

3. 解題步驟：
   - **步驟 1：檢查起點是否為障礙。若是，直接返回 0。**
   - **步驟 2：建立與原網格同大小的 dp 表，初始化 dp[0][0] 為 1。**
   - **步驟 3：初始化第一列與第一欄的走法（要考慮障礙情況）。**
   - **步驟 4：遍歷其餘格子，若無障礙則累加上方與左方的走法。**
   - **步驟 5：回傳 dp[m-1][n-1] 即為解答。**

重點筆記：
1. **dp[i][j]：代表從起點走到格子 (i, j) 的所有合法路徑總數。**
2. **障礙物（值為 1）無法走過，因此設為 0。**
3. **第一列與第一欄的初始化需特別處理，因為只有一個方向可抵達。**
4. **時間複雜度：O(m × n)**，因為每格都需計算一次。
5. **空間複雜度：O(m × n)**（若使用原地覆蓋或一維陣列可再優化）。

函數功能說明：
- `uniquePathsWithObstacles(obstacleGrid)`: 傳入一個障礙網格，回傳所有從左上角走到右下角的合法路徑數。
- `if (obstacleGrid[0][0] === 1)`: 判斷起點是否為障礙。
- `const dp = Array.from(...)`: 建立一個 dp 表來紀錄每格路徑數。
- `dp[0][0] = 1`: 起始點的初始化。
- `dp[i][j] = dp[i-1][j] + dp[i][j-1]`: 主動態規劃遞推公式。
- `return dp[m - 1][n - 1]`: 回傳終點格子的累積路徑數。
*/