class Solution {
    /**
     * @param {number} n
     * @return {boolean}
     */
    divisorGame = function(n) {
        // 根據遊戲規則分析，Alice 在 N 上的輸贏狀態只與 N 的奇偶性有關。
        // 如果 N 是偶數，Alice 總可以選擇 x = 1 (因為 1 是所有正整數的因數，且 0 < 1 < N 當 N > 1)。
        // N 變成 N - 1，這是一個奇數。
        // 如果 N 是奇數，Alice 只能選擇奇數因數 x (因為奇數的因數都是奇數)。
        // N 變成 N - x，這是一個偶數 (奇數 - 奇數 = 偶數)。
        // 遊戲以 N=1 結束，N=1 是一個必輸狀態（沒有合法的 x 可以選擇）。
        // 因此，Alice 從偶數 N 開始，可以一直將數字傳遞給 Bob 時變為奇數。
        // Bob 從奇數 N 開始，必須將數字傳遞給 Alice 時變為偶數。
        // 最終，數字會遞減到 2，然後 Alice 選擇 x=1，變成 1。Bob 面臨 1 輸掉。
        // 如果 Alice 從奇數 N 開始，她必須把它變成偶數給 Bob，Bob 會把它變成奇數給 Alice... 最終 Alice 會面臨 1 輸掉。

        // 所以，Alice 贏當且僅當 N 是偶數。

        // 我們只需要判斷 N 是否為偶數。
        return n % 2 === 0; // 使用模運算符 % 檢查 n 除以 2 的餘數是否為 0。
    };
}



// 測試範例
let n = 3;


// 創建 Solution 的實例
let solution = new Solution();


console.log(solution.divisorGame(n));  

/*
LeetCode 1025: 除數博弈 (Divisor Game) (Node.js 實現)

題目翻譯：
Alice 和 Bob 輪流玩一個遊戲，Alice 先手。
遊戲從一個正整數 N 開始。
在每一輪中，當前玩家選擇一個數字 x，滿足 0 < x < N 且 N % x == 0。
然後，玩家將 N 替換為 N - x。
如果玩家不能進行操作，則該玩家輸掉遊戲。
返回如果 Alice 贏得遊戲，則返回 true；否則，返回 false。

題目需求：
1. 接收一個正整數 `n` 作為輸入。
2. 判斷在按照遊戲規則進行時，先手玩家 Alice 是否能贏得遊戲。
3. 遊戲規則涉及選擇因數並減去，直到無法再進行操作（N 變為 1）。

解題思路與拆解：
這是一個典型的博弈論問題。我們可以通過分析遊戲的狀態（當前的數字 N）和可能的轉移來確定輸贏。通過分析小數字 N 的情況，可以發現一個簡單的規律。

1. 問題分析：
   - 遊戲是一個有限的、無偏的、完美信息的兩人遊戲，可以用來判斷先手是贏是輸。
   - 遊戲狀態由當前的數字 N 決定。
   - 如果一個狀態可以轉移到至少一個必輸狀態，那麼這個狀態是必贏狀態。
   - 如果一個狀態只能轉移到必贏狀態，那麼這個狀態是必輸狀態。
   - 遊戲在 N=1 時結束，因為沒有滿足條件 0 < x < 1 且 1 % x == 0 的 x 存在，所以 N=1 是必輸狀態。

2. 解題方法選擇：
   - 博弈分析/數學歸納法 (本解法採用) - 通過分析小數字 N 的輸贏情況，發現規律並證明。
   - 動態規劃 (DP) (Alternative) - 建立一個 DP 陣列 `dp[i]` 表示當數字為 i 時先手是否能贏。`dp[i]` 為 true 如果存在一個因數 x (0 < x < i, i % x == 0) 使得 `dp[i - x]` 為 false。

3. 解題步驟 (博弈分析)：
   - 分析 N=1 時的情況： Alice 面臨 1，沒有因數 x 滿足 0 < x < 1，Alice 無法行動，輸。N=1 是必輸態。
   - 分析 N=2 時的情況： Alice 面臨 2，可以選擇 x=1 (2 % 1 == 0, 0 < 1 < 2)。N 變為 2 - 1 = 1。Bob 面臨 1 (必輸態)。所以 Alice 贏。N=2 是必贏態。
   - 分析 N=3 時的情況： Alice 面臨 3，只能選擇 x=1 (3 % 1 == 0, 0 < 1 < 3)。N 變為 3 - 1 = 2。Bob 面臨 2 (必贏態)。Alice 只能將 N 轉移到 Bob 的必贏態，所以 Alice 輸。N=3 是必輸態。
   - 分析 N=4 時的情況： Alice 面臨 4，可以選擇 x=1 或 x=2。
     - 選擇 x=1: N 變為 3。Bob 面臨 3 (必輸態)。Alice 轉移到 Bob 的必輸態，Alice 贏。
     - 選擇 x=2: N 變為 2。Bob 面臨 2 (必贏態)。Alice 轉移到 Bob 的必贏態，Alice 贏。
     - 只要存在一個轉移可以到達必輸態，當前狀態就是必贏態。Alice 可以選擇 x=1 轉移到 N=3 (Bob 必輸態)，所以 N=4 是必贏態。
   - 觀察發現：N=1 輸，N=2 贏，N=3 輸，N=4 贏。似乎 N 是偶數 Alice 贏，N 是奇數 Alice 輸。
   - **證明規律：**
     - 如果 N 是偶數：Alice 總可以選擇 x=1 (因為 1 是所有正整數的因數，且當 N > 1 時 0 < 1 < N)。N 變成 N-1，這是一個奇數。Alice 總可以把一個偶數狀態轉移給 Bob，讓 Bob 面臨奇數狀態。
     - 如果 N 是奇數：任何奇數 N 的因數 x 必須是奇數。選擇 x 後，N 變成 N-x (奇數 - 奇數 = 偶數)。Alice 只能把一個奇數狀態轉移給 Bob，讓 Bob 面臨偶數狀態。
     - 遊戲在 N=1 (必輸態) 結束。
     - 如果 Alice 從偶數開始，她傳給 Bob 奇數，Bob 傳回偶數給她... 最終 Alice 會把 2 傳給 Bob，Bob 選擇 x=1，變成 1，Alice 面臨 1 輸。錯了，是 Alice 把 2 變成 1 給 Bob，Bob 面臨 1 輸。所以 Alice 從偶數開始贏。
     - 如果 Alice 從奇數開始，她傳給 Bob 偶數，Bob 傳回奇數給她... 最終 Bob 會把 2 傳給 Alice，Alice 必須把它變成 1 給 Bob，Bob 面臨 1 輸。錯了，是 Alice 從奇數開始輸。 Bob 會一直把她轉移到偶數，她只能回到奇數。最終，她會在數字遞減到 1 的過程中遇到 1 輸掉。
     - 結論：Alice 贏當且僅當 N 是偶數。

4. 解題步驟 (基於規律)：
   - 接收輸入 N。
   - 判斷 N 是否為偶數 (`N % 2 === 0`)。
   - 返回判斷結果。

重點筆記：
1.  **博弈論：** 遊戲問題常通過分析狀態的輸贏性來解決。
2.  **必輸態：** 無法進行任何合法操作的狀態（N=1）。
3.  **必贏態：** 可以轉移到至少一個必輸態的狀態。
4.  **規律：** 對於這個遊戲，輸贏只取決於起始數字的奇偶性。
5.  **證明：** 通過分析奇數和偶數狀態的轉移來證明規律。

時間複雜度：O(1)。只需執行一個簡單的模運算。
空間複雜度：O(1)。只使用了常數量的變數。

函數功能說明：
- `divisorGame(n)` (作為 Solution 類別的一個方法): 接收一個正整數 `n`，判斷先手玩家 Alice 在遊戲中是否能贏，返回布林值。
- `return n % 2 === 0`: 判斷 `n` 是否為偶數，並直接返回結果。
*/