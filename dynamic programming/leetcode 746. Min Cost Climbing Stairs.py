from typing import List
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        if not cost:
            return 0
        if len(cost)==1:
            return cost[0]
        n = len(cost)
        # dp[i] 代表到達第 i 階台階的最低成本
        dp = [0] * (n + 1)  # 長度為 n+1，dp[n] 代表到達頂端的最低成本

        # 基礎情況：到達第 0 階和第 1 階的成本為 0 (因為可以從這裡開始)
        dp[0] = 0
        dp[1] = 0

        # 迭代計算到達每一階台階的最低成本
        for i in range(2, n + 1):
            # 到達第 i 階台階可以從第 i-1 階或第 i-2 階爬上來
            # 選擇成本較低的路徑
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])

        # dp[n] 即為到達頂端的最低成本
        return dp[n]


cost = [1,100,1,1,1,100,1,1,100,1]
solution = Solution()

print(solution.minCostClimbingStairs(cost))

'''
LeetCode 746: 爬樓梯的最低成本 (Min Cost Climbing Stairs) (Python 實現)

題目翻譯：
你是一個爬樓梯愛好者，你想要以最低的成本爬到樓梯的頂端。
樓梯有 n 階台階，編號從 0 到 n-1。每階台階 i 都有一個成本 cost[i]，
你可以在台階 i 支付 cost[i] 後選擇向上爬一階或兩階。

你可以從台階 0 或台階 1 開始爬，請你計算達到樓梯頂端的最低總成本。

題目需求：
1. 計算爬到樓梯頂端的最低總成本。
2. 可以從台階 0 或台階 1 開始。
3. 每階台階都有一個成本，爬上該階必須支付。
4. 每次可以爬一階或兩階。

解題思路與拆解：
1. 問題分析：
   - 最佳化問題：求最低成本。
   - 最優子結構：到達第 i 階的最低成本取決於到達第 i-1 階和第 i-2 階的最低成本。
   - 重疊子問題：計算過程中會重複計算子問題，例如計算到達第 i 階的成本時，會用到計算到達第 i-1 和 i-2 階的成本，而計算更高階的成本又會用到這些子問題的結果。
   - 因此，可以使用動態規劃 (Dynamic Programming) 來解決。

2. 解題方法選擇：
   - 方法一：動態規劃 (Dynamic Programming) (本解法採用) - 時間 O(N)，空間 O(N) 或 O(1) (空間優化後)
   - 方法二：遞迴 (Recursion) (不推薦，效率較差，會有大量重複計算)

3. 解題步驟 (動態規劃方法)：
   - 定義 DP 陣列：
     - `dp[i]` 代表到達第 i 階台階的最低成本。
     - 由於目標是到達樓梯頂端，我們可以將頂端視為第 n 階 (假設樓梯有 n 階，索引為 0 到 n-1)。因此，`dp` 陣列長度設為 n+1，`dp[n]` 代表到達頂端的最低成本。
   - 初始化 DP 陣列的基礎情況：
     - `dp[0] = 0`: 到達第 0 階的成本為 0，因為可以從這裡開始，且題目描述 "你可以從台階 0 或台階 1 開始爬"。
     - `dp[1] = 0`: 到達第 1 階的成本也為 0，原因同上，可以從這裡開始。
   - 狀態轉移方程式：
     - 對於第 i 階台階 (i >= 2)，要到達第 i 階，可以從第 i-1 階爬一階，或者從第 i-2 階爬兩階。
     - 從第 i-1 階爬一階到達第 i 階，需要支付 `cost[i-1]` 的成本 (注意 cost 陣列索引從 0 開始)。到達第 i-1 階的最低成本是 `dp[i-1]`。所以總成本是 `dp[i-1] + cost[i-1]`。
     - 從第 i-2 階爬兩階到達第 i 階，需要支付 `cost[i-2]` 的成本。到達第 i-2 階的最低成本是 `dp[i-2]`. 所以總成本是 `dp[i-2] + cost[i-2]`。
     - 選擇成本較低的路徑作為到達第 i 階的最低成本，因此狀態轉移方程式為：
       `dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`
   - 迭代計算：
     - 使用迴圈從 i = 2 迭代到 n，根據狀態轉移方程式計算 `dp[i]` 的值。
   - 返回結果：
     - 迴圈結束後，`dp[n]` 即為到達樓梯頂端的最低總成本，返回 `dp[n]`。

重點筆記：
1. **動態規劃 (Dynamic Programming)**:
   - 使用動態規劃解決最佳化問題，通過將問題分解為子問題並儲存子問題的解來避免重複計算。
   - 關鍵步驟：定義 DP 狀態、初始化基礎情況、找出狀態轉移方程式、迭代計算。

2. **DP 狀態定義**:
   - `dp[i]` 代表到達第 i 階台階的最低成本，明確定義狀態的含義是動態規劃的關鍵。
   - 注意 `dp` 陣列的長度設定為 n+1，以方便表示到達頂端的狀態 `dp[n]`。

3. **基礎情況 (Base Cases)**:
   - `dp[0] = 0` 和 `dp[1] = 0` 是遞迴的起點，也是動態規劃的基礎。
   - 題目說明可以從第 0 或第 1 階開始，因此到達這兩階的成本為 0。

4. **狀態轉移方程式 (Transition Function)**:
   - `dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])` 是核心的遞迴關係式。
   - 它描述了如何從已知的子問題解 (dp[i-1] 和 dp[i-2]) 推導出當前問題的解 (dp[i])。

5. **時間複雜度**:
   - O(N)，其中 N 是樓梯的階數。
   - 迴圈迭代 N-1 次，每次迭代中的操作為常數時間。

6. **空間複雜度**:
   - O(N)，用於儲存 DP 陣列 `dp`。
   - 可以優化為 O(1)，因為計算 `dp[i]` 時只需要 `dp[i-1]` 和 `dp[i-2]` 的值，可以使用兩個變數來儲存前兩個狀態，而不需要整個 DP 陣列。 (本範例為了程式碼清晰易懂，未使用空間優化)

7. **適用場景**:
   - 適合解決具有最優子結構和重疊子問題的優化問題，特別是路徑規劃、成本最小化等問題。
   - 爬樓梯問題是動態規劃的經典入門範例。

範例解析 (範例 1: cost = [10, 15, 20]):
- 初始化: `dp = [0, 0, 0, 0]` (長度為 4，對應 0, 1, 2, 3 階，dp[3] 為頂端)
- `dp[0] = 0`
- `dp[1] = 0`
- i = 2: `dp[2] = min(dp[1] + cost[1], dp[0] + cost[0]) = min(0 + 15, 0 + 10) = 10`  (從第 0 階爬兩階到第 2 階)
- i = 3: `dp[3] = min(dp[2] + cost[2], dp[1] + cost[1]) = min(10 + 20, 0 + 15) = 15`  (從第 1 階爬兩階到第 3 階)
- 返回 `dp[3] = 15`

範例解析 (範例 2: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]):
- 初始化: `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` (長度為 11)
- `dp[0] = 0`
- `dp[1] = 0`
- i = 2: `dp[2] = min(dp[1] + cost[1], dp[0] + cost[0]) = min(0 + 100, 0 + 1) = 1`
- i = 3: `dp[3] = min(dp[2] + cost[2], dp[1] + cost[1]) = min(1 + 1, 0 + 100) = 2`
- i = 4: `dp[4] = min(dp[3] + cost[3], dp[2] + cost[2]) = min(2 + 1, 1 + 1) = 2`
- i = 5: `dp[5] = min(dp[4] + cost[4], dp[3] + cost[3]) = min(2 + 1, 2 + 1) = 3`
- i = 6: `dp[6] = min(dp[5] + cost[5], dp[4] + cost[4]) = min(3 + 100, 2 + 1) = 3`
- i = 7: `dp[7] = min(dp[6] + cost[6], dp[5] + cost[5]) = min(3 + 1, 3 + 100) = 4`
- i = 8: `dp[8] = min(dp[7] + cost[7], dp[6] + cost[6]) = min(4 + 1, 3 + 1) = 4`
- i = 9: `dp[9] = min(dp[8] + cost[8], dp[7] + cost[7]) = min(4 + 100, 4 + 1) = 5`
- i = 10: `dp[10] = min(dp[9] + cost[9], dp[8] + cost[8]) = min(5 + 1, 4 + 1) = 6`
- 返回 `dp[10] = 6`

函式功能說明 (已移動到程式碼的行內註解):
- `class Solution`：定義解決方案類別。
- `minCostClimbingStairs(cost)`：計算爬樓梯最低成本的核心方法。
- `dp = [0] * (n + 1)`：初始化 DP 陣列，用於儲存到達每一階台階的最低成本。
- `dp[0] = 0; dp[1] = 0;`: 設定基礎情況，到達第 0 和第 1 階的成本為 0。
- `for i in range(2, n + 1):`: 迴圈迭代計算從第 2 階到頂端的最低成本。
- `dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`: 狀態轉移方程式，計算到達第 i 階的最低成本。
- `return dp[n]`: 返回到達頂端的最低成本。
- `cost1 = [...]`, `cost2 = [...]`: 定義測試用例的成本陣列。
- `solution = Solution()`: 創建 `Solution` 實例。
- `print(...)`: 調用 `minCostClimbingStairs` 方法並打印結果。
'''