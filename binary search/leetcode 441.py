class Solution:
    def arrangeCoins(self, n: int) -> int:
        """
        LeetCode 441: 排列硬幣 (Arranging Coins)

        你總共有 n 枚硬幣，並想用這些硬幣來建造一個階梯形的硬幣堆。階梯形硬幣堆的每一行從上到下都必須正好有 k 枚硬幣，其中 k 從 1 開始。

        給你一個整數 n，返回你可以形成的完整階梯行的總行數。

        範例 1:
        n = 5
        硬幣可以排列成以下幾行:
        ¤
        ¤ ¤
        ¤ ¤
        因為第三行不完整，所以返回 2。

        範例 2:
        n = 8
        硬幣可以排列成以下幾行:
        ¤
        ¤ ¤
        ¤ ¤ ¤
        ¤ ¤
        因為第四行不完整，所以返回 3。

        :param n: 你擁有的硬幣總數
        :return: 你可以形成的完整階梯行的總行數
        """
        left, right = 1, n  # 設定二分搜尋的左右邊界，行數最小為 1，最大可能為 n（每行只有一個硬幣）

        while left <= right:
            mid = (left + right) // 2  # 計算中間值，作為可能的完整行數
            # 計算形成 mid 行完整階梯所需的硬幣總數，公式為 mid * (mid + 1) / 2
            cost = mid * (mid + 1) // 2

            if cost == n:
                return mid  # 如果所需的硬幣數正好等於 n，則 mid 就是答案
            elif cost < n:
                left = mid + 1  # 如果所需的硬幣數小於 n，表示可以嘗試更多的行，所以將左邊界移到 mid 的右邊
            else:
                right = mid - 1  # 如果所需的硬幣數大於 n，表示 mid 行太多了，所以將右邊界移到 mid 的左邊

        return right  # 如果迴圈結束時沒有找到完全匹配的行數，則 right 的值是最大的完整行數

n = 5
solution = Solution()
print(solution.arrangeCoins(n))
'''
LeetCode 441: 排列硬幣 (Arranging Coins) (Python 實現)

題目翻譯：
你總共有 n 枚硬幣，並想用這些硬幣來建造一個階梯形的硬幣堆。階梯形硬幣堆的每一行從上到下都必須正好有 k 枚硬幣，其中 k 從 1 開始。

給你一個整數 n，返回你可以形成的完整階梯行的總行數。

題目需求：
1. 給定硬幣總數 n。
2. 建造一個階梯形硬幣堆，第 k 行恰好有 k 個硬幣。
3. 返回可以形成的完整階梯行的最大數量。

解題思路與拆解：
1. 問題分析：
   - 我們需要找到一個最大的整數 `k`，使得前 `k` 行的硬幣總數小於或等於 `n`。
   - 前 `k` 行的硬幣總數可以用公式 `k * (k + 1) / 2` 計算。
   - 這是一個尋找滿足特定條件的最大值的問題，可以使用二分搜尋來高效地解決。

2. 解題方法選擇：
   - 方法一：迭代 (Iteration) - 從 1 開始逐行增加，直到硬幣不夠用。時間 O(sqrt(n))。
   - 方法二：二分搜尋 (Binary Search) (本解法採用) - 時間 O(log n)。
   - 方法三：數學公式 - 可以直接推導出公式，但可能涉及浮點數運算和取整。

3. 解題步驟 (二分搜尋方法)：
   - 設定搜尋範圍：
     - 最小可能的完整行數是 1。
     - 最大可能的完整行數是 `n`（當 `n` 很小時，每行只有一個硬幣）。
     - 因此，我們設定左邊界 `left = 1`，右邊界 `right = n`。
   - 執行二分搜尋：
     - 在 `while left <= right` 的迴圈中：
       - 計算中間值 `mid = (left + right) // 2`，代表我們假設可以形成的完整行數。
       - 計算形成 `mid` 行所需的硬幣總數 `cost = mid * (mid + 1) // 2`。
       - 比較 `cost` 和 `n`：
         - 如果 `cost == n`，表示正好可以使用 `n` 個硬幣形成 `mid` 行，那麼 `mid` 就是答案，直接返回。
         - 如果 `cost < n`，表示可以使用 `n` 個硬幣形成至少 `mid` 行，我們可以嘗試更多的行，所以將左邊界更新為 `left = mid + 1`。
         - 如果 `cost > n`，表示 `mid` 行需要的硬幣超過了 `n`，所以我們需要嘗試更少的行，將右邊界更新為 `right = mid - 1`。
   - 返回結果：
     - 當 `while` 迴圈結束時，如果沒有找到 `cost == n` 的情況，`right` 的值將會是最大的完整行數。這是因為當 `cost > n` 時，我們會將 `right` 減 1，使其指向前一個有效的完整行數。

重點筆記：
1. **二分搜尋 (Binary Search) 的應用**:
   - 適用於在有序或具有單調性的搜尋空間中尋找目標值。
   - 在本題中，隨著行數的增加，所需的硬幣總數也是單調遞增的，因此可以使用二分搜尋。

2. **搜尋範圍的設定**:
   - 正確設定二分搜尋的左右邊界是關鍵。最小行數為 1，最大行數不可能超過 `n`。

3. **中間值的計算**:
   - 使用 `(left + right) // 2` 進行整數除法，計算中間值。

4. **硬幣總數的計算公式**:
   - 前 `k` 個正整數的和的公式是 `k * (k + 1) / 2`。

5. **迴圈終止條件和返回值**:
   - 當 `left > right` 時，迴圈終止。
   - 如果找到 `cost == n`，直接返回 `mid`。
   - 如果沒有找到完全匹配，迴圈結束後 `right` 會指向最大的完整行數。

6. **時間複雜度**:
   - O(log n)，因為二分搜尋每次都將搜尋範圍減半。

7. **空間複雜度**:
   - O(1)，只使用了常數級別的額外空間。

8. **適用場景**:
   - 適用於需要在單調遞增或遞減的範圍內尋找滿足特定條件的值。

範例解析 (n = 5):
- `left = 1`, `right = 5`
- 第一次迭代: `mid = (1 + 5) // 2 = 3`, `cost = 3 * (3 + 1) // 2 = 6`. `cost > n`, `right = 3 - 1 = 2`.
- 第二次迭代: `left = 1`, `right = 2`. `mid = (1 + 2) // 2 = 1`, `cost = 1 * (1 + 1) // 2 = 1`. `cost < n`, `left = 1 + 1 = 2`.
- 第三次迭代: `left = 2`, `right = 2`. `mid = (2 + 2) // 2 = 2`, `cost = 2 * (2 + 1) // 2 = 3`. `cost < n`, `left = 2 + 1 = 3`.
- 第四次迭代: `left = 3`, `right = 2`. 迴圈終止，返回 `right = 2`。

範例解析 (n = 8):
- `left = 1`, `right = 8`
- 第一次迭代: `mid = (1 + 8) // 2 = 4`, `cost = 4 * (4 + 1) // 2 = 10`. `cost > n`, `right = 4 - 1 = 3`.
- 第二次迭代: `left = 1`, `right = 3`. `mid = (1 + 3) // 2 = 2`, `cost = 2 * (2 + 1) // 2 = 3`. `cost < n`, `left = 2 + 1 = 3`.
- 第三次迭代: `left = 3`, `right = 3`. `mid = (3 + 3) // 2 = 3`, `cost = 3 * (3 + 1) // 2 = 6`. `cost < n`, `left = 3 + 1 = 4`.
- 第四次迭代: `left = 4`, `right = 3`. 迴圈終止，返回 `right = 3`。

函式功能說明 (已移動到程式碼的行內註解):
- `class Solution`: 定義解決方案類別。
- `arrangeCoins(self, n: int) -> int`: 計算可以形成的完整階梯行的總行數的核心方法。
- `left, right = 1, n`: 初始化二分搜尋的左右邊界。
- `while left <= right`: 二分搜尋的迴圈條件。
- `mid = (left + right) // 2`: 計算中間值（可能的完整行數）。
- `cost = mid * (mid + 1) // 2`: 計算形成 `mid` 行所需的硬幣總數。
- `if cost == n`: 如果所需硬幣數等於 `n`，則返回 `mid`。
- `elif cost < n`: 如果所需硬幣數小於 `n`，則更新左邊界。
- `else`: 如果所需硬幣數大於 `n`，則更新右邊界。
- `return right`: 返回最大的完整行數。
- `n = 5`: 設定測試範例的硬幣總數。
- `solution = Solution()`: 創建 `Solution` 實例。
- `print(solution.arrangeCoins(n))`: 調用 `arrangeCoins` 方法並打印結果。
'''