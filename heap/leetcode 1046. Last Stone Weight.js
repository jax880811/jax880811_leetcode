const { MinHeap } = require('heap-js');

class Solution {
    lastStoneWeight(stones) {
        /**
         * 計算最後一塊石頭的重量
         * @param {number[]} stones - 石頭重量列表
         * @return {number} - 最後剩下的石頭重量，如果沒有石頭剩下則返回 0
         */
        // 創建一個最小堆，並將所有石頭的重量取負數（模擬最大堆）
        const maxHeap = new MinHeap();
        for (const stone of stones) {
            maxHeap.push(-stone); // 取負數模擬最大堆
        }

        while (maxHeap.size() > 1) {
            // 取出最重的兩個石頭（取負數還原）
            const stone1 = -maxHeap.pop();
            const stone2 = -maxHeap.pop();

            if (stone1 !== stone2) {
                // 如果兩石頭重量不同，把剩下的重量放回堆中（取負數）
                maxHeap.push(-(stone1 - stone2));
            }
        }

        // 如果堆裡還有石頭，返回其重量（取負數還原），否則返回0
        return maxHeap.size() > 0 ? -maxHeap.pop() : 0;
    }
}

// 測試範例
const stones = [2, 7, 4, 1, 8, 1];
const solution = new Solution();
console.log(solution.lastStoneWeight(stones)); // 輸出結果

/*
LeetCode 1046: 最後一塊石頭的重量

題目翻譯：
有一堆石頭，每塊石頭的重量都是正整數。每一回合，我們選擇兩塊最重的石頭並將它們一起粉碎。假設兩塊石頭的重量分別為 x 和 y，且 x <= y。粉碎的結果如下：
1. 如果 x == y，則兩塊石頭都會被完全粉碎；
2. 如果 x != y，則重量為 x 的石頭會被完全粉碎，而重量為 y 的石頭會剩下 y - x。
最後，最多只會剩下一塊石頭。返回這塊石頭的重量。如果沒有石頭剩下，則返回 0。

題目需求：
1. 模擬石頭粉碎的過程，每次選擇兩塊最重的石頭進行粉碎。
2. 返回最後剩下的石頭重量，如果沒有石頭剩下，則返回 0。

原始代碼的問題：
1. 使用排序的方式來找到最重的兩塊石頭，時間複雜度較高（每次排序為 O(n log n)）。
2. 插入新石頭時，使用 insert 方法，時間複雜度為 O(n)，效率較低。
3. 整體時間複雜度為 O(n^2 log n)，對於大數據量會較慢。

解題思路與拆解：
1. 問題分析：
   - 每次需要找到兩塊最重的石頭，這可以使用最大堆（Max Heap）來高效實現。
   - 粉碎後的結果需要重新放回堆中，直到堆中只剩下一塊石頭或沒有石頭。

2. 解題方法選擇：
   - 使用堆（Heap）來高效找到最重的兩塊石頭，並處理粉碎後的結果。
   - 使用 `heap-js` 模組的 `MinHeap`，並通過取負數來模擬最大堆。

3. 解題步驟：
   - 將石頭列表轉換為最大堆（通過取負數實現）。
   - 每次取出堆頂的兩個元素（最重的兩塊石頭）。
   - 根據粉碎規則處理這兩塊石頭，並將結果放回堆中。
   - 重複上述步驟，直到堆中剩下一塊石頭或沒有石頭。

重點筆記：
1. **堆的使用**:
   - 使用 `heap-js` 模組的 `MinHeap`，並通過取負數來模擬最大堆。
   - 這樣可以避免手動實現最大堆的複雜性。

2. **時間複雜度**:
   - 每次堆操作的時間複雜度為 O(log n)。
   - 整體時間複雜度為 O(n log n)。

3. **空間複雜度**:
   - 需要 O(n) 的空間來存儲堆。

4. **適用場景**:
   - 適用於需要高效找到最大或最小元素的場景。
   - 例如優先級隊列、任務調度等。

範例解析：
- 輸入：stones = [2, 7, 4, 1, 8, 1]
- 過程：
  - 第一回合：8 和 7 粉碎，剩下 1，石頭列表變為 [2, 4, 1, 1, 1]。
  - 第二回合：4 和 2 粉碎，剩下 2，石頭列表變為 [1, 1, 1, 2]。
  - 第三回合：2 和 1 粉碎，剩下 1，石頭列表變為 [1, 1, 1]。
  - 第四回合：1 和 1 粉碎，剩下 0，石頭列表變為 [1]。
  - 最後剩下 1。
- 輸出：1

函式功能說明：
- `class Solution`：封裝解決方案的類。
- `lastStoneWeight(stones)`：計算最後一塊石頭的重量。
- `MinHeap`：`heap-js` 模組的最小堆類，用於模擬最大堆。
- `push(val)`：將元素插入堆中。
- `pop()`：移除並返回堆的最小元素。
- `size()`：返回堆的大小。
*/