#include <iostream>
#include <vector>
using namespace std;

/*
================================================================================
LeetCode 88: Merge Sorted Array - 合併兩個有序陣列
================================================================================

題目描述：
給定兩個非遞減整數陣列 nums1 和 nums2，以及兩個整數 m 和 n，
分別表示 nums1 和 nums2 中的元素數目。
將 nums2 合併到 nums1 中，使最終陣列按非遞減順序排列。

注意：
- nums1 的長度為 m + n，其中前 m 個元素表示應合併的元素，
  後 n 個元素為 0，應被忽略。
- nums2 的長度為 n。

範例：
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]

================================================================================
解題思路分析
================================================================================

核心概念：從後往前合併（Three Pointers Technique）

為什麼要從後往前？
1. 避免覆蓋 nums1 中的有效數據
2. 利用 nums1 後半部分的空閒空間
3. 確保合併過程的穩定性

演算法步驟：
1. 設定三個指針：
   - p1: 指向 nums1 最後一個有效元素 (m-1)
   - p2: 指向 nums2 最後一個元素 (n-1)  
   - p: 指向 nums1 最後一個位置 (m+n-1)

2. 比較並填充：
   - 比較 nums1[p1] 和 nums2[p2]
   - 將較大的值放入 nums1[p]
   - 移動對應指針

3. 處理剩餘元素：
   - 如果 nums2 還有剩餘元素，繼續填充
   - 如果 nums1 還有剩餘元素，無需處理（已在正確位置）

================================================================================
Pseudo Code 虛擬碼
================================================================================

Algorithm: Merge Sorted Arrays
Input: nums1[], m, nums2[], n
Output: Merged array in nums1

1. Initialize pointers:
   p1 = m - 1          // Last valid element in nums1
   p2 = n - 1          // Last element in nums2  
   p = m + n - 1       // Last position in nums1

2. While p2 >= 0:      // While there are elements in nums2
   a. If p1 >= 0 AND nums1[p1] > nums2[p2]:
      - nums1[p] = nums1[p1]
      - p1 = p1 - 1
   b. Else:
      - nums1[p] = nums2[p2]
      - p2 = p2 - 1
   c. p = p - 1

3. Return nums1

================================================================================
時間複雜度分析
================================================================================

時間複雜度：O(m + n)
- 每個元素最多被訪問一次
- 總共需要遍歷 m + n 個元素

空間複雜度：O(1)
- 只使用常數個額外變數
- 原地操作，不額外分配記憶體

================================================================================
C++ 實作
================================================================================
*/

class Solution {
public:
    /**
     * 合併兩個有序陣列
     * @param nums1 第一個陣列，長度為 m+n
     * @param m nums1 中有效元素的數量
     * @param nums2 第二個陣列，長度為 n
     * @param n nums2 中元素的數量
     */
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // 邊界條件檢查
        if (n == 0) return;  // nums2 為空，無需合併
        
        // 初始化三個指針
        int p1 = m - 1;      // nums1 最後一個有效元素
        int p2 = n - 1;      // nums2 最後一個元素
        int p = m + n - 1;   // nums1 最後一個位置
        
        // 從後往前合併
        while (p2 >= 0) {
            // 比較兩個陣列的元素，選擇較大的放入 nums1[p]
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p] = nums1[p1];  // 選擇 nums1 的元素
                p1--;
            } else {
                nums1[p] = nums2[p2];  // 選擇 nums2 的元素
                p2--;
            }
            p--;  // 移動目標位置指針
        }
        
        // 注意：如果 nums1 還有剩餘元素，它們已經在正確位置
        // 如果 nums2 還有剩餘元素，上面的迴圈會處理完
    }
};

/*
================================================================================
詳細執行流程分析
================================================================================

以範例為例：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

初始狀態：
nums1: [1, 2, 3, 0, 0, 0]
       p1=2              p=5
nums2: [2, 5, 6]
       p2=2

步驟 1: p1=2, p2=2, p=5
- nums1[2] = 3, nums2[2] = 6
- 6 > 3，所以 nums1[5] = 6
- p2--, p--
nums1: [1, 2, 3, 0, 0, 6]
       p1=2            p=4
nums2: [2, 5, 6]
       p2=1

步驟 2: p1=2, p2=1, p=4
- nums1[2] = 3, nums2[1] = 5
- 5 > 3，所以 nums1[4] = 5
- p2--, p--
nums1: [1, 2, 3, 0, 5, 6]
       p1=2          p=3
nums2: [2, 5, 6]
       p2=0

步驟 3: p1=2, p2=0, p=3
- nums1[2] = 3, nums2[0] = 2
- 3 > 2，所以 nums1[3] = 3
- p1--, p--
nums1: [1, 2, 3, 3, 5, 6]
         p1=1        p=2
nums2: [2, 5, 6]
       p2=0

步驟 4: p1=1, p2=0, p=2
- nums1[1] = 2, nums2[0] = 2
- 2 == 2，選擇 nums2 的元素（else 分支）
- nums1[2] = 2
- p2--, p--
nums1: [1, 2, 2, 3, 5, 6]
         p1=1      p=1
nums2: [2, 5, 6]
       p2=-1

p2 < 0，迴圈結束
最終結果：nums1 = [1, 2, 2, 3, 5, 6]

================================================================================
常見錯誤與注意事項
================================================================================

1. 指針初始化錯誤：
   - 錯誤：int p1 = m;  // 應該指向最後一個有效元素
   - 正確：int p1 = m - 1;

2. 邊界條件處理：
   - 忘記檢查 p1 >= 0
   - 可能導致陣列越界

3. 迴圈條件：
   - 錯誤：while (p >= 0)  // 會處理不必要的元素
   - 正確：while (p2 >= 0)  // 只需處理 nums2 的元素

4. 記憶體管理：
   - C++ 中 vector 會自動管理記憶體
   - 不需要手動釋放記憶體

================================================================================
進階討論：其他解法比較
================================================================================

解法 1: 從前往後合併（需要額外空間）
- 時間複雜度：O(m + n)
- 空間複雜度：O(m)
- 需要複製 nums1 的前 m 個元素

解法 2: 先合併再排序
- 時間複雜度：O((m + n) log(m + n))
- 空間複雜度：O(1)
- 效率較低

解法 3: 從後往前合併（本解法）
- 時間複雜度：O(m + n)
- 空間複雜度：O(1)
- 最佳解法

================================================================================
測試程式
================================================================================
*/

// 輔助函數：打印陣列
void printArray(const vector<int>& arr, const string& name) {
    cout << name << ": [";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i];
        if (i < arr.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
}

int main() {
    // 測試案例 1
    cout << "=== 測試案例 1 ===" << endl;
    vector<int> nums1 = {1, 2, 3, 0, 0, 0};
    int m = 3;
    vector<int> nums2 = {2, 5, 6};
    int n = 3;
    
    cout << "合併前：" << endl;
    printArray(nums1, "nums1");
    printArray(nums2, "nums2");
    
    Solution solution;
    solution.merge(nums1, m, nums2, n);
    
    cout << "合併後：" << endl;
    printArray(nums1, "nums1");
    cout << endl;
    
    // 測試案例 2：nums2 為空
    cout << "=== 測試案例 2 ===" << endl;
    vector<int> nums3 = {1, 2, 3};
    int m2 = 3;
    vector<int> nums4 = {};
    int n2 = 0;
    
    cout << "合併前：" << endl;
    printArray(nums3, "nums3");
    printArray(nums4, "nums4");
    
    solution.merge(nums3, m2, nums4, n2);
    
    cout << "合併後：" << endl;
    printArray(nums3, "nums3");
    cout << endl;
    
    // 測試案例 3：nums1 為空
    cout << "=== 測試案例 3 ===" << endl;
    vector<int> nums5 = {0, 0, 0};
    int m3 = 0;
    vector<int> nums6 = {1, 2, 3};
    int n3 = 3;
    
    cout << "合併前：" << endl;
    printArray(nums5, "nums5");
    printArray(nums6, "nums6");
    
    solution.merge(nums5, m3, nums6, n3);
    
    cout << "合併後：" << endl;
    printArray(nums5, "nums5");
    
    return 0;
}

/*
================================================================================
國家考試重點整理
================================================================================

1. 演算法設計原則：
   - 從後往前操作避免覆蓋
   - 利用現有空間進行原地操作
   - 考慮邊界條件

2. 指針操作技巧：
   - 三指針技術的應用
   - 指針移動的時機
   - 邊界檢查的重要性

3. 時間空間複雜度：
   - 時間：O(m + n)
   - 空間：O(1)
   - 理解為什麼是最優解

4. 程式設計技巧：
   - 迴圈條件的選擇
   - 條件判斷的順序
   - 變數命名的意義

5. 除錯技巧：
   - 追蹤指針位置
   - 檢查邊界條件
   - 驗證最終結果

================================================================================
*/
