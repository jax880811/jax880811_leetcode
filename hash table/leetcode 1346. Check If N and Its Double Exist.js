class Solution {
    /**
     * @param {number[]} arr
     * @return {boolean}
     */
    checkIfExist = function (arr) {
        // 如果陣列長度小於 2，則不可能存在兩個不同的索引滿足條件，直接返回 false
        if (arr.length < 2) {
            return false;
        }
        // 創建一個 Set 集合，用於存儲已經遍歷過的數字
        const set = new Set();
        // 使用外層迴圈遍歷陣列中的每個元素，索引為 i
        for (let i = 0; i < arr.length; i++) {
            // 將當前元素添加到 Set 集合中，以便後續檢查是否存在其兩倍或一半
            set.add(arr[i]);
            // 使用內層迴圈再次遍歷陣列中的每個元素，索引為 j，用於與外層迴圈的元素進行比較
            for (let j = 0; j < arr.length; j++) {
                // 如果內外層迴圈的索引相同，則跳過，因為題目要求是不同的索引
                if (j === i) {
                    continue;
                }
                // 特殊處理兩個 0 的情況：如果陣列中存在兩個 0，則滿足條件，直接返回 true
                if (arr[i] === 0 && arr[j] === 0) {
                    return true;
                }
                // 如果當前外層或內層的元素是 0，則跳過本次內層迴圈的判斷。
                // 注意：這個條件可能導致錯誤，因為如果一個數是 0，它的兩倍也是 0，應該被考慮。
                if (arr[i] === 0 || arr[j] === 0) {
                    continue;
                }
                // 檢查 Set 中是否已經存在當前內層元素 arr[j] 的兩倍，或者當前外層元素 arr[i] 的兩倍是否等於當前內層元素 arr[j]
                if (set.has(arr[j] * 2) || arr[i] * 2 === arr[j]) {
                    return true; // 如果找到滿足條件的兩個數字，返回 true
                }
            }
        }
        // 如果遍歷完整個陣列都沒有找到滿足條件的兩個數字，返回 false
        return false;
    }
}

//自己的作法

// 測試範例
let arr = [0, 0];

// 創建 Solution 的實例
let solution = new Solution();


console.log(solution.checkIfExist(arr));

/*
LeetCode 1346: 檢查整數 N 及其兩倍是否存在 (Check If N and Its Double Exist) (Node.js 實現)

題目翻譯：
給定一個整數陣列 `arr`，判斷是否存在兩個不同的索引 `i` 和 `j`，使得 `arr[i] == 2 * arr[j]` 或 `arr[j] == 2 * arr[i]`。

題目需求：
1. 檢查陣列中是否存在兩個不同的元素，其中一個是另一個的兩倍。
2. 這兩個元素的索引必須不同。

解題思路與拆解：
1. 問題分析：
   - 需要遍歷陣列中的所有可能的元素對。
   - 對於每一對元素，檢查它們之間是否滿足兩倍關係。
   - 需要注意索引不能相同。
   - 需要特別處理 0 的情況，因為 0 的兩倍是 0。

2. 解題方法選擇：
   - 方法一：暴力搜尋 (雙重迴圈) (本解法採用) - 時間 O(N^2)，空間 O(N) (用於 Set)
   - 方法二：使用哈希集合 (Set) 優化 - 時間 O(N)，空間 O(N)

3. 解題步驟 (暴力搜尋方法)：
   - 首先判斷陣列長度是否小於 2，如果小於 2，則不可能存在兩個不同的索引，直接返回 `false`。
   - 創建一個 `Set` 集合 `set`，用於存儲已經遍歷過的數字，以方便後續的查找。
   - 使用外層迴圈遍歷陣列 `arr`，索引為 `i`。
   - 將當前外層迴圈的元素 `arr[i]` 添加到 `set` 中。
   - 使用內層迴圈再次遍歷陣列 `arr`，索引為 `j`。
   - 在內層迴圈中，首先判斷索引 `i` 和 `j` 是否相同，如果相同則跳過本次內層迴圈。
   - 處理兩個 0 的情況：如果 `arr[i]` 和 `arr[j]` 都是 0，則滿足條件，返回 `true`。
   - **注意：** 程式碼中 `if(arr[i]===0 || arr[j]===0) { continue; }` 這個條件是不正確的，應該移除或修改。因為如果一個數是 0，它的兩倍也是 0，應該被考慮。
   - 檢查是否滿足兩倍關係：
     - 檢查 `set` 中是否已經存在 `arr[j] * 2` 這個數字（表示在之前的遍歷中遇到過 `arr[j] * 2`，且當前元素是 `arr[j]`）。
     - 或者檢查當前外層迴圈的元素 `arr[i]` 的兩倍是否等於當前內層迴圈的元素 `arr[j]`。
   - 如果上述任一條件滿足，則返回 `true`。
   - 如果遍歷完所有的元素對都沒有找到滿足條件的，則返回 `false`。

重點筆記：
1. **暴力搜尋**: 使用雙重迴圈檢查所有可能的元素對。
2. **Set 的使用**: 使用 `Set` 來記錄已經遍歷過的數字，可以稍微提高查找效率。
3. **時間複雜度**: O(N^2)，因為使用了嵌套的迴圈來遍歷陣列。
4. **空間複雜度**: O(N)，用於存儲 `Set` 中的元素。
5. **關於 0 的處理**: 需要特別注意 0 的情況，因為 0 的兩倍仍然是 0。

更好的解決方法 (使用 Set 優化)：
- 創建一個空的 `Set` 集合 `seen`。
- 遍歷陣列 `arr` 中的每個元素 `num`。
- 對於每個 `num`，檢查 `seen` 中是否包含 `num * 2` 或 `num / 2`（注意要處理 `num` 為奇數的情況）。
- 如果包含，則返回 `true`。
- 將當前元素 `num` 添加到 `seen` 集合中。
- 另外，需要單獨處理 0 的情況。可以在遍歷之前或之後統計 0 的出現次數，如果出現次數大於等於 2，則返回 `true`。

範例解析 (arr = [0, 0]):
- 陣列長度為 2，不小於 2。
- `set` 初始化為 `{}`。
- 外層迴圈 `i = 0`，`arr[0] = 0`，`set` 添加 0，`set` 為 `{0}`。
- 內層迴圈 `j = 0`，`j === i`，跳過。
- 內層迴圈 `j = 1`，`arr[1] = 0`。`arr[i] === 0 && arr[j] === 0` 為 true，返回 `true`。

函式功能說明 (已移動到程式碼的行內註解):
- `class Solution`: 定義解決方案類別。
- `checkIfExist(arr)`: 檢查是否存在滿足條件的兩個數字的核心方法。
- `if (arr.length < 2) { return false; }`: 如果陣列長度小於 2，直接返回 false。
- `const set = new Set();`: 創建一個 Set 集合用於存儲遍歷過的數字。
- `for (let i = 0; i < arr.length; i++)`: 外層迴圈遍歷陣列。
- `set.add(arr[i]);`: 將當前元素添加到 Set 中。
- `for (let j = 0; j < arr.length; j++)`: 內層迴圈遍歷陣列。
- `if (j===i){ continue; }`: 如果索引相同則跳過。
- `if(arr[i]===0 && arr[j]===0){ return true; }`: 處理兩個 0 的情況。
- `if(arr[i]===0 || arr[j]===0){ continue; }`: **這個條件可能導致錯誤，應該注意。**
- `if (set.has(arr[j]*2) || arr[i]*2 === arr[j] ) { return true; }`: 檢查是否存在兩倍關係。
- `return false;`: 如果沒有找到滿足條件的數字對，返回 false。
- `let arr = [0,0];`: 設定測試範例。
- `let solution = new Solution();`: 創建 Solution 實例。
- `console.log(solution.checkIfExist(arr));`: 調用方法並打印結果。
*/